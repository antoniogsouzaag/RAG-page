import React, { memo } from "react";

interface OptimizedImageProps extends React.ImgHTMLAttributes<HTMLImageElement> {
  /** Either a full URL/path (with extension) or a base path without extension */
  src: string;
  alt: string;
  className?: string;
  /** If true, mark image as priority (eager load) */
  priority?: boolean;
  /** Sizes attribute for responsive images */
  sizes?: string;
  /** Width for aspect ratio hint */
  width?: number;
  /** Height for aspect ratio hint */
  height?: number;
}

function stripExtension(p: string) {
  return p.replace(/\.(png|jpg|jpeg|webp|avif)$/i, "");
}

// Widths generated by script/convert-images.cjs - defined outside for performance
const WIDTHS = [320, 640, 960, 1280, 1600] as const;

function OptimizedImage({ 
  src, 
  alt, 
  className, 
  priority = false, 
  sizes = '100vw',
  width,
  height,
  ...rest 
}: OptimizedImageProps) {
  const base = stripExtension(src);

  const avifSrcSet = WIDTHS.map(w => `${base}-${w}.avif ${w}w`).join(', ');
  const webpSrcSet = WIDTHS.map(w => `${base}-${w}.webp ${w}w`).join(', ');
  const fallback = `${base}-1600.png`;

  return (
    <picture>
      <source srcSet={avifSrcSet} type="image/avif" sizes={sizes} />
      <source srcSet={webpSrcSet} type="image/webp" sizes={sizes} />
      <img 
        src={fallback} 
        alt={alt} 
        className={className} 
        loading={priority ? 'eager' : 'lazy'} 
        decoding="async" 
        fetchPriority={priority ? 'high' : 'low'}
        width={width}
        height={height}
        {...rest} 
      />
    </picture>
  );
}

// Memoize to prevent unnecessary re-renders
export default memo(OptimizedImage);
